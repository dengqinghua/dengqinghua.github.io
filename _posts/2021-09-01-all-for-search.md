---
layout: post
toc: true
categories: showed note
title: 检索技术学习笔记
---

## 检索的本质

| 名称 | 特点 | 按下标查询复杂度 | 更新复杂度 | 缺点 |
| :-------------: | :-------------: | :-------------: | :-------------: | :-------------: |
| 数组 | 连续空间存储 | O(1) | O(n) | 需要向操作系统申请连续空间, 在频繁修改或者 大数据 的情况下更新效率会比较差 |
| 链表 | 非连续空间存储 | O(n) | O(1) | 检索效率低 |


使用 **二分查找法** 检索一个值是否存在

| 名称 | 按下标查询复杂度 | 更新复杂度 |
| :-------------: | :-------------: |
| 有序数组 | O(logn) | O(n) |
| 有序链表 | O(n) | O(n) |

> 这里的 O(n) + O(logn) 是认为等于 O(n)

检索核心思路

- 有序化
- 快速减少查询范围(如 二分查找法, 快速过滤掉一半的内容)

检索维度

- 数据量大小
- 使用场景(查询/更新)
- 数据模型本身的存储空间(如 二叉树 和 红黑树 需要存储的元数据的大小不同)

## 平衡二叉树
一般来说，我们之前学习的都是先有 二叉树 的概念和特性，再去聊二叉树的 查询/更新 复杂度 等

这里给了一个很好的思路：**如何让 链表 可以通过 O(logn) 的复杂度 进行 二分查找?** 答案之一就是 二叉树 的设计

```java
class Node {
  Node left;
  Node right;
  Object value;
}
```

二叉树的最坏的情况是形成一个链表，即使有序，查询复杂度也是 O(n) 此时需要改造为二叉平衡树(AVL) 或者 红黑树 等， 本质上来说，是为了让树的左边和右边尽可能的平衡

AVL 树可以保证高平衡度, 但是 AVL 的节点的更新需要 **多次旋转**, 并且需要 **保存平衡因子**(树的高度) 等, 所以一些更新频率高的场景，基本都会使用 红黑树 来作为基础的数据结构
