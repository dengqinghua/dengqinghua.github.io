<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>检索技术探索</title>

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="检索技术探索" />
<meta name="author" content="dengqinghua" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="方案设计 可选的搜索方案" />
<meta property="og:description" content="方案设计 可选的搜索方案" />
<link rel="canonical" href="http://localhost:4000/all-for-search.html" />
<meta property="og:url" content="http://localhost:4000/all-for-search.html" />
<meta property="og:site_name" content="Dengqinghua.42" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-09-01T00:00:00+08:00" />
<script type="application/ld+json">
{"headline":"检索技术探索","dateModified":"2021-09-01T00:00:00+08:00","datePublished":"2021-09-01T00:00:00+08:00","url":"http://localhost:4000/all-for-search.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/all-for-search.html"},"author":{"@type":"Person","name":"dengqinghua"},"description":"方案设计 可选的搜索方案","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Dengqinghua.42" />

  <link rel="shortcut icon" type="image/x-icon" href="/logo.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
  <link rel="stylesheet" href="/assets/css/zoom.css" />
  <link rel="stylesheet" href="/assets/css/gitalk.css" />
  <link rel="stylesheet" href="/assets/css/syntax.css" />
  <script src="assets/js/mermaid.min.js"></script>
  <script src="assets/js/jquery.min.js"></script>
  <script src="assets/js/zoom.min.js"></script>
  <script src="assets/js/zoom_init.js"></script>
  <script src="assets/js/mermaid_config.js"></script>
  <script src="assets/js/gitalk.min.js"></script>
  <script src="assets/js/gitalk_init.js"></script>
  <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script src="assets/js/mathjax_init.js"></script>
</head>
<body a="light">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">..</a>

<article>
  <p class="post-meta">
    <time datetime="2021-09-01 00:00:00 +0800">2021-09-01</time>
  </p>
  
  <h1>检索技术探索</h1>

  <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2">
<a href="#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1">方案设计</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E5%8F%AF%E9%80%89%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E6%A1%88">可选的搜索方案</a></li>
<li class="toc-entry toc-h3">
<a href="#%E4%BE%8B%E5%AD%90">例子</a>
<ul>
<li class="toc-entry toc-h4"><a href="#mysql">MySQL</a></li>
<li class="toc-entry toc-h4"><a href="#h2">H2</a></li>
<li class="toc-entry toc-h4"><a href="#es">ES</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-entry toc-h2">
<a href="#%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88">落地方案</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E6%90%9C%E7%B4%A2">搜索</a></li>
<li class="toc-entry toc-h3"><a href="#%E7%B4%A2%E5%BC%95">索引</a></li>
<li class="toc-entry toc-h3"><a href="#%E9%83%A8%E7%BD%B2">部署</a></li>
<li class="toc-entry toc-h3"><a href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E6%9E%90">任务分析</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%BC%94%E8%BF%9B%E8%AE%A1%E5%88%92">演进计划</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#%E6%A3%80%E7%B4%A2%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA">检索基础理论</a></li>
<li class="toc-entry toc-h2">
<a href="#es-%E5%AE%9E%E6%88%98">ES 实战</a>
<ul>
<li class="toc-entry toc-h3"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li class="toc-entry toc-h3"><a href="#devtools">DevTools</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">倒排索引</a></li>
<li class="toc-entry toc-h3"><a href="#analyer-%E5%88%86%E8%AF%8D%E5%99%A8">Analyer 分词器</a></li>
<li class="toc-entry toc-h3"><a href="#relevance-%E7%9B%B8%E5%85%B3%E6%80%A7">Relevance 相关性</a></li>
<li class="toc-entry toc-h3"><a href="#mapping">Mapping</a></li>
<li class="toc-entry toc-h3"><a href="#aggregation">Aggregation</a></li>
<li class="toc-entry toc-h3"><a href="#term-%E5%92%8C-text">Term 和 Text</a></li>
<li class="toc-entry toc-h3"><a href="#bool-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E8%AF%A2">bool， 数字类型的查询</a></li>
<li class="toc-entry toc-h3"><a href="#%E7%9B%B8%E5%85%B3%E5%BA%A6%E8%AE%A1%E7%AE%97">相关度计算</a></li>
<li class="toc-entry toc-h3"><a href="#query-%E5%92%8C-filter">Query 和 Filter</a></li>
<li class="toc-entry toc-h3"><a href="#function-score-query">Function Score Query</a></li>
<li class="toc-entry toc-h3"><a href="#serach-template">Serach Template</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%90%9C%E7%B4%A2%E6%8E%A8%E8%8D%90-search-as-you-type-autocomplete-contextcomplete">搜索推荐 search as you type， AutoComplete， ContextComplete</a></li>
<li class="toc-entry toc-h3"><a href="#es-%E5%88%86%E5%B8%83%E5%BC%8F">ES 分布式</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%88%86%E7%89%87%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">分片的生命周期</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5-%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0">深度分页, 并发更新</a></li>
<li class="toc-entry toc-h3"><a href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2">聚合查询</a></li>
<li class="toc-entry toc-h3"><a href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2">关联查询</a></li>
<li class="toc-entry toc-h3"><a href="#%E9%87%8D%E5%BB%BA%E7%B4%A2%E5%BC%95">重建索引</a></li>
<li class="toc-entry toc-h3"><a href="#%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1">数据建模</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#reference">Reference</a></li>
</ul>
<h2 id="方案设计">
<a class="anchor" href="#%E6%96%B9%E6%A1%88%E8%AE%BE%E8%AE%A1" aria-hidden="true"><span class="octicon octicon-link"></span></a>方案设计</h2>
<h3 id="可选的搜索方案">
<a class="anchor" href="#%E5%8F%AF%E9%80%89%E7%9A%84%E6%90%9C%E7%B4%A2%E6%96%B9%E6%A1%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>可选的搜索方案</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">方案</th>
      <th style="text-align: center">优点</th>
      <th style="text-align: center">缺点</th>
      <th>扩展性</th>
      <th>难度</th>
      <th>实现方式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">MySQL</td>
      <td style="text-align: center">接入成本小， 原生的 MySQL 支持简单的全文索引 和 ngram 分词</td>
      <td style="text-align: center">功能<a href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-restrictions.html" target="_blank" rel="noopener noreferrer">有限</a>， 不支持复杂的分词逻辑， 不支持预先设置字段权重</td>
      <td>⭐️</td>
      <td>⭐️</td>
      <td>直接接入并使用 MyBatisPlus 进行查询即可</td>
    </tr>
    <tr>
      <td style="text-align: center">内存(H2)</td>
      <td style="text-align: center">速度快，可使用 <a href="https://www.h2database.com/html/main.html" target="_blank" rel="noopener noreferrer">H2</a> 和 <a href="http://www.h2database.com/javadoc/index.html" target="_blank" rel="noopener noreferrer">Lucene</a> 结合进行检索， 当前数据量大概为 500K， 可考虑全部导入</td>
      <td style="text-align: center">数据量变大之后容易导致 OOM， 需要处理多实例的数据同步问题</td>
      <td>⭐️⭐️</td>
      <td>⭐️⭐️⭐️</td>
      <td>1. 接入 H2<br> 2. 提供同步更新机制 <br>3. OOM 优化 <br>4. 分词优化方案和调试方案</td>
    </tr>
    <tr>
      <td style="text-align: center">ES</td>
      <td style="text-align: center">主流， 满足基本的搜索需求， 丰富的 API， 分词功能支持较好</td>
      <td style="text-align: center">引入第三方组件， 容易造成单点， 服务可靠性无法保证</td>
      <td>⭐️⭐️⭐️⭐️⭐️</td>
      <td>⭐️⭐️</td>
      <td>1. 接入 ES<br> 2. 实现 ES Wrapper <br>3. 提供统一的搜索接口</td>
    </tr>
  </tbody>
</table>

<h3 id="例子">
<a class="anchor" href="#%E4%BE%8B%E5%AD%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>例子</h3>
<h4 id="mysql">
<a class="anchor" href="#mysql" aria-hidden="true"><span class="octicon octicon-link"></span></a>MySQL</h4>
<p>给 media 表的 content 字段 添加全文索引， 这里使用了 <a href="https://dev.mysql.com/doc/refman/5.7/en/fulltext-search-ngram.html" target="_blank" rel="noopener noreferrer">ngram</a> 作为分词器</p>

<p>分词的字数由 <code class="language-plaintext highlighter-rouge">ngram_token_size</code> 参数进行控制</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="nv">`media`</span> <span class="k">ADD</span> <span class="n">FULLTEXT</span><span class="p">(</span><span class="nv">`content`</span><span class="p">)</span> <span class="k">WITH</span> <span class="n">PARSER</span> <span class="n">ngram</span>
</code></pre></div></div>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">id</span><span class="err">，</span> <span class="n">content</span>  <span class="k">from</span> <span class="n">media</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">230</span><span class="err">，</span> <span class="mi">231</span><span class="p">)</span><span class="err">\</span><span class="k">G</span>

<span class="o">***************************</span> <span class="mi">1</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
     <span class="n">id</span><span class="p">:</span> <span class="mi">230</span>
<span class="n">content</span><span class="p">:</span> <span class="err">{</span><span class="nv">"description"</span><span class="p">:</span><span class="nv">"【为什么失眠】</span><span class="se">\n\n\n</span><span class="nv">【专注练习】</span><span class="se">\n</span><span class="nv"> 为了避免大脑走神，"</span><span class="err">}</span>

<span class="o">***************************</span> <span class="mi">2</span><span class="p">.</span> <span class="k">row</span> <span class="o">***************************</span>
     <span class="n">id</span><span class="p">:</span> <span class="mi">231</span>
<span class="n">content</span><span class="p">:</span> <span class="err">{</span><span class="nv">"description"</span><span class="p">:</span><span class="nv">"描述文案"</span><span class="err">，</span><span class="nv">"title"</span><span class="p">:</span><span class="nv">"播放器标题"</span><span class="err">}</span>
</code></pre></div></div>

<p>查看匹配的分数， 这里拿了两个 id 作为例子</p>
<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">id</span><span class="err">，</span><span class="k">match</span> <span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="n">AGAINST</span> <span class="p">(</span><span class="s1">'为什么失眠'</span><span class="p">)</span> <span class="k">as</span> <span class="n">score</span> <span class="k">from</span> <span class="n">media</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">230</span><span class="err">，</span> <span class="mi">231</span><span class="p">)</span>

<span class="o">+</span><span class="c1">-----+--------------------+</span>
<span class="o">|</span> <span class="n">id</span>  <span class="o">|</span> <span class="n">score</span>              <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+--------------------+</span>
<span class="o">|</span> <span class="mi">230</span> <span class="o">|</span> <span class="mi">4</span><span class="p">.</span><span class="mi">3379950523376465</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">231</span> <span class="o">|</span>                  <span class="mi">0</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+--------------------+</span>
<span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">05</span> <span class="n">sec</span><span class="p">)</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">id</span><span class="err">，</span><span class="k">match</span> <span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="n">AGAINST</span> <span class="p">(</span><span class="s1">'失眠'</span><span class="p">)</span> <span class="k">as</span> <span class="n">score</span> <span class="k">from</span> <span class="n">media</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">230</span><span class="err">，</span> <span class="mi">231</span><span class="p">);</span>
<span class="o">+</span><span class="c1">-----+-------------------+</span>
<span class="o">|</span> <span class="n">id</span>  <span class="o">|</span> <span class="n">score</span>             <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+-------------------+</span>
<span class="o">|</span> <span class="mi">230</span> <span class="o">|</span> <span class="mi">8</span><span class="p">.</span><span class="mi">675990104675293</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">231</span> <span class="o">|</span>                 <span class="mi">0</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+-------------------+</span>

<span class="n">mysql</span><span class="o">&gt;</span> <span class="k">select</span> <span class="n">id</span><span class="err">，</span><span class="k">match</span> <span class="p">(</span><span class="n">content</span><span class="p">)</span> <span class="n">AGAINST</span> <span class="p">(</span><span class="s1">'眠'</span><span class="p">)</span> <span class="k">as</span> <span class="n">score</span> <span class="k">from</span> <span class="n">media</span> <span class="k">where</span> <span class="n">id</span> <span class="k">in</span> <span class="p">(</span><span class="mi">230</span><span class="err">，</span> <span class="mi">231</span><span class="p">);</span>
<span class="o">+</span><span class="c1">-----+-------+</span>
<span class="o">|</span> <span class="n">id</span>  <span class="o">|</span> <span class="n">score</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+-------+</span>
<span class="o">|</span> <span class="mi">230</span> <span class="o">|</span>     <span class="mi">0</span> <span class="o">|</span>
<span class="o">|</span> <span class="mi">231</span> <span class="o">|</span>     <span class="mi">0</span> <span class="o">|</span>
<span class="o">+</span><span class="c1">-----+-------+</span>
<span class="mi">2</span> <span class="k">rows</span> <span class="k">in</span> <span class="k">set</span> <span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">04</span> <span class="n">sec</span><span class="p">)</span>
</code></pre></div></div>

<h4 id="h2">
<a class="anchor" href="#h2" aria-hidden="true"><span class="octicon octicon-link"></span></a>H2</h4>
<p>例子见 <a href="https://zhuanlan.zhihu.com/p/142833556" target="_blank" rel="noopener noreferrer">H2 的全文检索功能</a></p>

<p>H2 可以结合 Lucene 一起进行使用， 但是从 API 的设计和扩展性来说，都有比较大的限制，可以作为测试使用，不适合用在生产环境中</p>

<h4 id="es">
<a class="anchor" href="#es" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES</h4>
<p>ES 作为专业的搜索引擎，有丰富的功能和 API，在<a href="./3-month-sharing#elk">之前</a>我们便使用了 ELK 做日志相关的收集和查询，
在稳定性和查询速度上面都要对应的保证。</p>

<p>相比于 MySQL，ES 提供更细粒度的相关度控制(<a href="https://www.elastic.co/guide/en/app-search/current/relevance-tuning-guide.html" target="_blank" rel="noopener noreferrer">Relevance Tuning</a>)， 即可以指定每个字段的搜索权重，例子</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-X</span> GET <span class="s1">'https://es/search'</span> <span class="nt">-H</span> <span class="s1">'Content-Type: application/json'</span> <span class="se">\</span>
<span class="nt">-d</span> <span class="s1">'{
  "search_fields": {
    "title": {
      "weight": 10
    },
    "description": {
      "weight": 1
    },
    "states": {
      "weight": 2
    }
  },
  "query": "mountains"
}'</span>
</code></pre></div></div>

<p>对比于 MySQL， 更提供了全套的管理后台，可在 Kibana 进行对应的索引管理和监控等操作</p>

<p>另外，除了 weight/boost 设置之外， ES 还支持前缀匹配，同义词检索，分词插件等功能，其中 同义词，分词插件 可直接在腾讯云后台中更新</p>

<h2 id="落地方案">
<a class="anchor" href="#%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88" aria-hidden="true"><span class="octicon octicon-link"></span></a>落地方案</h2>
<h3 id="搜索">
<a class="anchor" href="#%E6%90%9C%E7%B4%A2" aria-hidden="true"><span class="octicon octicon-link"></span></a>搜索</h3>

<div class="mermaid">
flowchart TD;
    onMemeroy([缓存 获取搜索结果<br>热词检索/TopK 等]);
    es([es 检索]);
    E([返回搜索结果]);
    E1([返回推荐数据]);
    onMemeroy--&gt;|有结果| E
    onMemeroy--&gt;|无结果| es
    es--&gt;|有结果| E
    es--&gt;|无结果| E1
</div>

<h3 id="索引">
<a class="anchor" href="#%E7%B4%A2%E5%BC%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>索引</h3>
<p>采用 ES 作为主要的搜索引擎， 通过事件维护索引的更新</p>

<div class="mermaid">
graph LR
    subgraph 查询
      cache(内存);
      es(ES API);
    end
    subgraph 索引更新
      EventHandler(Pulsa队列);
      storage1(存储1 <br> ES-主查询引擎);
      storage2(存储2 <br> 内存-热词,TopK 等信息);
    end
    subgraph 源数据事件
      event1(单曲/合集/QE/DE 更新);
      event2(老师更新);
      event3(标签更新);
    end
    subgraph 宽表 Schema
      field(索引字段);
      weight(搜索权重值);
    end

    event1 &amp; event2 &amp; field &amp; weight--&gt;EventHandler--&gt;storage1 &amp; storage2;
    cache--&gt;storage1;
    es--&gt;storage2;
</div>

<h3 id="部署">
<a class="anchor" href="#%E9%83%A8%E7%BD%B2" aria-hidden="true"><span class="octicon octicon-link"></span></a>部署</h3>
<ol>
  <li>如果采用 H2 作为搜索引擎， 为了服务的简单行来说，需要考虑 <strong>新建项目</strong>， 而且需要维护好数据更新的问题</li>
  <li>如果使用 ES 或者 MySQL 作为搜索引擎， 则可不需要考虑单独起项目，在原有项目上开发即可</li>
  <li>无论使用哪一种方案，都需要将搜索服务部署到单独的服务器中，通过 Nginx 的二级域名进行流量转发和分流处理， 该部分在 Nginx 层控制即可</li>
</ol>

<h3 id="任务分析">
<a class="anchor" href="#%E4%BB%BB%E5%8A%A1%E5%88%86%E6%9E%90" aria-hidden="true"><span class="octicon octicon-link"></span></a>任务分析</h3>
<ol>
  <li>
    <p>热词维护</p>

    <p>后台配置，存储 MySQL，使用 guava cache，全量缓存 热词对应的id 至 内存中</p>
  </li>
  <li>
    <p>索引维护</p>

    <ul>
      <li>确定可供搜索的字段来源</li>
      <li>字段更新之后，需要发送对应的事件，使得 ES 进行索引的更新</li>
    </ul>
  </li>
  <li>
    <p>搜索</p>

    <ul>
      <li>优先匹配 热词， 该部分直接从缓存中获取</li>
      <li>
        <p>热词中不存在时， 则使用 ES 进行查询</p>

        <div class="language-java highlighter-rouge">
<div class="highlight"><pre class="highlight"><code><span class="nc">QueryBuilders</span><span class="o">.</span><span class="na">multiMatchQuery</span><span class="o">(</span><span class="s">"搜索词"</span><span class="o">).</span><span class="na">fields</span><span class="o">(</span><span class="nc">Map</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">"词汇1"</span><span class="o">,</span> <span class="mi">1</span><span class="n">f</span><span class="err">，</span> <span class="s">"词汇2"</span><span class="o">,</span> <span class="mi">2</span><span class="n">f</span><span class="o">));</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>冷启动数据</p>

    <p>未获取到搜索结果时处理如下:</p>

    <ul>
      <li>如果是搜索 es 未找到对应的数据结果， 则使用 人工配置的 推荐数据</li>
    </ul>
  </li>
  <li>
    <p>搜索词数据统计</p>

    <p>logstash 收集搜索相关的词， 下面的 <code class="language-plaintext highlighter-rouge">searchQ</code> 为搜索的词汇</p>

    <div class="language-ruby highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> <span class="n">filter</span> <span class="p">{</span>
    <span class="n">grok</span> <span class="p">{</span>
     <span class="n">match</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="s2">"message"</span> <span class="o">=&gt;</span> <span class="p">[</span><span class="s1">'%{TIMESTAMP_ISO8601:reqTime}  %{GREEDYDATA} params =[{"q":%{searchQ}}] %{GREEDYDATA}time cost = %{NUMBER:reqCostMs} ms'</span><span class="p">]</span> <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">mutate</span> <span class="p">{</span>
     <span class="n">convert</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="s2">"reqCostMs"</span> <span class="o">=&gt;</span> <span class="s2">"integer"</span> <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">date</span> <span class="p">{</span>
     <span class="n">match</span> <span class="o">=&gt;</span> <span class="p">[</span> <span class="s2">"reqTime"</span><span class="err">，</span> <span class="s2">"ISO8601"</span><span class="err">，</span> <span class="s2">"YYYY-MM-dd HH:mm:ss"</span><span class="err">，</span> <span class="s2">"YYYY-MM-dd HH:mm:ss.ZZZ"</span> <span class="p">]</span>
     <span class="n">target</span> <span class="o">=&gt;</span> <span class="s2">"reqTime"</span>
     <span class="n">locale</span> <span class="o">=&gt;</span> <span class="s2">"en"</span>
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>数据全量索引</p>
  </li>
  <li>
    <p>数据统计</p>

    <p>对于数据而言，常见的是 哪些词被经常搜索？搜索的结果的相关度怎么样？搜索的结果有多少人进行了点击？(CTR 是多少)</p>

    <p><img src="assets/images/search_result_example.png" alt="search_result_example"></p>
  </li>
  <li>
    <p>其他的优化</p>
    <ul>
      <li>分词优化，考虑使用不同的分词引擎(如 ik， ngram 等)</li>
      <li>同义词优化，配置对应的同义词进行检索优化</li>
      <li>拼音，错别字纠正</li>
      <li>搜索词补全</li>
    </ul>
  </li>
</ol>

<h3 id="演进计划">
<a class="anchor" href="#%E6%BC%94%E8%BF%9B%E8%AE%A1%E5%88%92" aria-hidden="true"><span class="octicon octicon-link"></span></a>演进计划</h3>

<div class="mermaid">
graph LR;
  input1([原始数据1 <br> 亿/千万])
  input2([原始数据2 <br> 亿/千万])
  input3([原始数据... <br> 亿/千万])
  callback(召回 <br>万/千);
  sort(归并排序 <br>千/百);
  filter(调整 <br>百/十);
  output([结果 <br> 十])
  input1 &amp; input2 &amp; input3--&gt;callback--&gt;sort--&gt;filter--&gt;output
</div>

<p><img src="assets/images/netflix_framework.png" alt="framework"></p>

<p>更多内容见 <a href="/recommend-sys.html#%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84">推荐系统探索</a></p>

<h2 id="检索基础理论">
<a class="anchor" href="#%E6%A3%80%E7%B4%A2%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA" aria-hidden="true"><span class="octicon octicon-link"></span></a>检索基础理论</h2>
<p>需要关注下面几点</p>

<ul>
  <li>快速的缩小检索范围
    <ul>
      <li>二分查找法， 缩小一半</li>
      <li>跳表， 跳动步长 &gt; 1</li>
      <li>B/B+树， 以磁盘片为步长，一次过滤掉一个(4K)或者多个快</li>
      <li>位图/Hash/布隆过滤器， 利用概率/数组下标 快速寻找或者判断元素</li>
      <li>Roaring Bitmap， 高位存储 bucket 信息，低位存储位图信息</li>
      <li>TopK &amp; 非精准 TopK</li>
    </ul>
  </li>
  <li>利用存储、访问特性进行检索优化， 估算内存和磁盘的空间占比， 减少磁盘IO(磁盘)， 利用磁盘的顺序读， 避免随机读
    <ul>
      <li>B+ 树</li>
      <li>日志记录使用 LSM 树</li>
    </ul>
  </li>
  <li>空间冗余换取时间
    <ul>
      <li>跳表， 冗余步长</li>
      <li>AVL， 冗余叶子高度信息</li>
      <li>倒排索引</li>
    </ul>
  </li>
  <li>缓存
    <ul>
      <li>热点数据使用 LRU 缓存</li>
    </ul>
  </li>
</ul>

<p>在工业界中，往往会几个算法组合起来进行使用，如使用跳表来实现 posting-list， 两个 posting-list 求交集的时候，直接将小的那个变成 Hash 等</p>

<p>另外，要注意两点</p>

<blockquote>

  <ol>
    <li>内存的检索效率比磁盘高许多，因此，能加载到内存中的数据，我们要尽可能加载到内存中。</li>
    <li>大数据集合拆成小数据集合处理(快速缩小检索范围)</li>
  </ol>
</blockquote>

<p><img src="assets/images/speed-in-2020.png" alt="speed-in-2020.png"></p>

<p>参考: <a href="https://colin-scott.github.io/personal_website/research/interactive_latency.html" target="_blank" rel="noopener noreferrer">数字</a></p>

<p>更新策略</p>

<ul>
  <li>Double Buffer， 利用冗余减少更新频率</li>
  <li>全量(只读) + 增量更新(可读可写)</li>
</ul>

<p>指导思想</p>

<ul>
  <li>索引和数据分离</li>
  <li>减少磁盘IO</li>
  <li>读写分离， 避免锁</li>
  <li>分层处理 (非精准 TopK -&gt; TopK)， 搜索降级</li>
</ul>

<h2 id="es-实战">
<a class="anchor" href="#es-%E5%AE%9E%E6%88%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES 实战</h2>
<h3 id="基本概念">
<a class="anchor" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" aria-hidden="true"><span class="octicon octicon-link"></span></a>基本概念</h3>
<ul>
  <li>Document Metadata
    <ul>
      <li>_index 索引名称</li>
      <li>_type 索引类型 7.0版本中只对应一个 type， 为 _doc</li>
      <li>_score 相关性打分</li>
      <li>_source 数据， 为 JSON 格式</li>
      <li>_version 更新的版本</li>
    </ul>
  </li>
  <li>Mapping 字段类型定义</li>
  <li>Setting 部署方式定义</li>
  <li>Data node 存储数据的 node</li>
  <li>Coordinating node 分发节点， 并发将请求拆分到不同的节点进行查询</li>
  <li>Primary/Replica Shard 主/副本分片</li>
  <li>green， yellow &amp; red 绿色代表主/副本分片均正常， 黄色代表副本分片不正常， 红色代表主分片不正常</li>
  <li>put 文档</li>
</ul>

<h3 id="devtools">
<a class="anchor" href="#devtools" aria-hidden="true"><span class="octicon octicon-link"></span></a>DevTools</h3>
<p>假设索引名称为 es_media</p>

<p>索引信息查询</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看 mapping 和 setting 信息</span>
GET /es_media
<span class="c"># 查询总数</span>
GET /es_media/_count
<span class="c"># 搜索内容 并查看分数</span>
POST /es_media/_search
</code></pre></div></div>

<p>cat 查询</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查看所有的索引信息</span>
GET /_cat/indices
<span class="c"># 查看所有的分片信息</span>
GET /_cat/shards
</code></pre></div></div>

<p>集群信息</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /_cluster/health
</code></pre></div></div>

<p>增删查改操作</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 创建记录</span>
POST /es_media/_doc
<span class="o">{</span>
  <span class="s2">"name"</span>: <span class="s2">"1"</span>
<span class="o">}</span>

<span class="c"># 更新或者创建 id=1024的记录， 该部分删除原有的索引进行重建</span>
PUT /es_media/_doc/1024
<span class="o">{</span>
  <span class="s2">"name"</span>: <span class="s2">"1"</span>
<span class="o">}</span>

<span class="c"># 更新索引</span>
POST /es_media/_update/1024
<span class="o">{</span>
  <span class="s2">"doc"</span>: <span class="o">{</span> <span class="s2">"internalName"</span>: <span class="s2">"this is new"</span> <span class="o">}</span>
<span class="o">}</span>

GET /es_media/_doc/1024

<span class="c"># 批量操作</span>
POST /_bulk
<span class="o">{}</span>

<span class="c"># 批量获取操作</span>
GET /_mget
<span class="o">{}</span>

<span class="c"># 批量查询</span>
GET /_msearch
<span class="o">{}</span>
</code></pre></div></div>

<p>分词器</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /_analyze
<span class="o">{</span>
  <span class="s2">"analyzer"</span>: <span class="s2">"standard"</span>，
  <span class="s2">"text"</span>: <span class="o">[</span><span class="s2">"今天是个好的日志"</span>, <span class="s2">"我吃了一顿烧烤"</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /es_media/_analyze
<span class="o">{</span>
  <span class="s2">"field"</span>: <span class="s2">"name"</span>,
  <span class="s2">"text"</span>: <span class="o">[</span><span class="s2">"nice"</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>profile 和 制定字段查询</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 查询字段为 title， 并查看 profile 其中 df 代表的是 default_field</span>
GET /es_media/_search?q<span class="o">=</span>测试&amp;df<span class="o">=</span>title
<span class="o">{</span>
  <span class="s2">"profile"</span>: <span class="nb">true</span>
<span class="o">}</span>
</code></pre></div></div>

<p>termQuery 和 phaseQuery</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># phaseQuery</span>
GET /es_media/_search?q<span class="o">=</span>title:<span class="s2">"测试 一下"</span>
<span class="o">{</span>
  <span class="s2">"profile"</span>: <span class="nb">true</span>
<span class="o">}</span>

<span class="c"># termQuery</span>
GET /es_media/_search?q<span class="o">=</span>title:<span class="s2">"测试 一下"</span>
<span class="o">{</span>
  <span class="s2">"profile"</span>: <span class="nb">true</span>
<span class="o">}</span>

<span class="c"># boolQuery， 必须要包括 测试 或者 一下</span>
GET /es_media/_search?q<span class="o">=</span>title:<span class="o">(</span>测试 一下<span class="o">)</span>
<span class="o">{</span>
  <span class="s2">"profile"</span>: <span class="nb">true</span>
<span class="o">}</span>

<span class="c"># 默认是 OR 的查询</span>

<span class="c"># 制定 AND</span>
GET /es_media/_search?q<span class="o">=</span>title:<span class="o">(</span>测试 AND 一下<span class="o">)</span>
<span class="o">{</span>
  <span class="s2">"profile"</span>: <span class="nb">true</span>
<span class="o">}</span>

<span class="c"># 测试的查询方式</span>
POST /es_media/_search?q<span class="o">=</span><span class="nb">id</span>:10
<span class="o">{</span>
  <span class="s2">"explain"</span>: <span class="nb">true</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 重建索引，将一个索引导入到另一个索引
POST _reindex
{
  "source": { "index": "source_index" },
  "dest": { "index": "new_index" }
}
</code></pre></div></div>

<h3 id="倒排索引">
<a class="anchor" href="#%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>倒排索引</h3>
<p>正排索引</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">document id</th>
      <th style="text-align: center">content</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">elasticsearch server</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">server devops good</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">elasticsearch very good</td>
    </tr>
  </tbody>
</table>

<p>倒排索引</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">term</th>
      <th style="text-align: center">count</th>
      <th style="text-align: center">document position in content</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">elasticsearch</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1:0 3:0</td>
    </tr>
    <tr>
      <td style="text-align: center">server</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1:1 2:0</td>
    </tr>
    <tr>
      <td style="text-align: center">good</td>
      <td style="text-align: center">2</td>
      <td style="text-align: center">2:0 3:0</td>
    </tr>
    <tr>
      <td style="text-align: center">very</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">3:1</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>单词词典(Term Dictionary)
    <ul>
      <li>B+ 树</li>
      <li>Hash</li>
    </ul>
  </li>
  <li>倒排列表(Posting List)
    <ul>
      <li>Doc ID</li>
      <li>TF (term frequency) 词频， 用于计算相关性</li>
      <li>Position 词出现的位置， 用于语句搜索</li>
      <li>Offset 位置， 用于高亮</li>
    </ul>
  </li>
</ul>

<h3 id="analyer-分词器">
<a class="anchor" href="#analyer-%E5%88%86%E8%AF%8D%E5%99%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>Analyer 分词器</h3>
<p>关键的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html" target="_blank" rel="noopener noreferrer">三个部分</a></p>

<div class="mermaid">
graph LR
    cf([Character ilters]);
    t([Tokenizer]);
    tf([Tokenizer Filter]);
    cf--&gt;t--&gt;tf
</div>

<ul>
  <li>Character Filters 过滤器，过滤掉一些如 &lt; &amp; 标签， 该部分会影响到倒排索引的 position 等信息</li>
  <li>Tokenizer 切分单词，比如按照空格，逗号切分 [“good better best”] 切分为 good， better， best</li>
  <li>Token Filter 加工单词，如删除 stopwords(a the 等)， 将大写改为小写， 删除违禁词等</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /_analyze
<span class="o">{</span>
  <span class="s2">"analyzer"</span>: <span class="s2">"standard"</span>，
  <span class="s2">"text"</span>: <span class="o">[</span><span class="s2">"今天是个好的日子"</span>, <span class="s2">"我吃了一顿烧烤"</span>, <span class="s2">"I feel good"</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /es_media/_analyze
<span class="o">{</span>
  <span class="s2">"field"</span>: <span class="s2">"name"</span>,
  <span class="s2">"text"</span>: <span class="o">[</span><span class="s2">"nice"</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>常见的 Analyzer</p>

<ul>
  <li>standard ES 的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyzer.html" target="_blank" rel="noopener noreferrer">默认</a>的分词器</li>
  <li>simple</li>
  <li>whitespace，将空格去掉</li>
  <li>stop 将 a，the 去掉</li>
  <li>keyword 不进行分词， 则使用 keyword</li>
  <li>pattern 正则分词</li>
  <li>language 不同语言的分词 (running 会变成 run，foxes 变成 fox 等)</li>
</ul>

<p>中文分词</p>

<blockquote>
  <p>难点：词语在不同地方的语境不同，假如 <strong>这个瓜不大好吃</strong> 分词为了 瓜，不大，好吃，则完全跟原来的意思相反了</p>
</blockquote>

<p>常用的中文分词器</p>

<ul>
  <li>icu_analyzer</li>
  <li><a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener noreferrer">ik_smart</a></li>
  <li><a href="https://github.com/hankcs/HanLP" target="_blank" rel="noopener noreferrer">HanLP</a></li>
  <li><a href="https://github.com/medcl/elasticsearch-analysis-pinyin" target="_blank" rel="noopener noreferrer">Pinyin</a></li>
</ul>

<p>注：可自定义 analyzer， 也可以定义 search_analyzer， 可参考 两者的<a href="https://stackoverflow.com/a/15932838" target="_blank" rel="noopener noreferrer">区别</a>，以及官方的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/specify-analyzer.html" target="_blank" rel="noopener noreferrer">建议</a></p>

<h3 id="relevance-相关性">
<a class="anchor" href="#relevance-%E7%9B%B8%E5%85%B3%E6%80%A7" aria-hidden="true"><span class="octicon octicon-link"></span></a>Relevance 相关性</h3>
<p>评估标准 Information Retrieval 通过下面三个结果来看相关性的结果好坏</p>

<ul>
  <li>Percision 精确度。除了返回精确结果，还包含了哪些非精确的结果</li>
  <li>Recall 查全率/召回率，还缺少了哪些数据未返回</li>
  <li>Ranking 排序</li>
</ul>

<p>该部分和机器学习里面的评估标准类似，有 True/False Positive 的概念</p>

<h3 id="mapping">
<a class="anchor" href="#mapping" aria-hidden="true"><span class="octicon octicon-link"></span></a>Mapping</h3>
<ul>
  <li>Dynamic Mapping， 自动创建 Mapping 和 字段
    <ul>
      <li>true 可以加字段，可以被索引</li>
      <li>false 可以加字段，不可以被索引</li>
      <li>strict 不可以加字段，不可以被索引</li>
    </ul>
  </li>
</ul>

<p>数组的类型依然是 text</p>

<ul>
  <li>keyword， 精确值类型， 认为是一个不可分割的词语， 如 App Store， 其他的精确值还包括 数字，日期 等， 该部分没有必要做分词的处理</li>
  <li>text， 全文本类型。</li>
</ul>

<h3 id="aggregation">
<a class="anchor" href="#aggregation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Aggregation</h3>
<ul>
  <li>Bucket，类似于 MySQL 的 group</li>
  <li>Metric，类似于 MySQL 的 count，min，max 等等</li>
  <li>Pipeline</li>
  <li>Matrix</li>
</ul>

<h3 id="term-和-text">
<a class="anchor" href="#term-%E5%92%8C-text" aria-hidden="true"><span class="octicon octicon-link"></span></a>Term 和 Text</h3>
<p>查询的分类可参考 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-query-builders.html" target="_blank" rel="noopener noreferrer">Building Queries</a></p>

<ol>
  <li>term 不会做分词处理，类似于 client 中的 keyword
    <ul>
      <li>注意，一些 analyzer 会做大小写转换，所以如果你的输入值为 iPHONE， 索引类型为 term， 存储到 ES 中 的 是 <code class="language-plaintext highlighter-rouge">iphone</code>， 此时拿 iPHONE 是无法查询到数据的</li>
      <li>可以使用 constant score 将查询转化，避免计算 score，提升性能</li>
      <li>可以用 es 的多字段属性，添加一个 <a href="https://stackoverflow.com/questions/48869795/difference-between-a-field-and-the-field-keyword" target="_blank" rel="noopener noreferrer">keyword</a> 字段</li>
    </ul>
  </li>
  <li>全文查询， 即 text， 查询的时候，会先将 text 分成 term，再进行不同的算分</li>
</ol>

<p>下面是一个 text: <strong>Fox Chicken Nice</strong> 被查询的例子</p>

<div class="mermaid">
graph LR
    fcn([Text <br>Fox Chicken Nice]);
    f([Term1 <br>Fox]);
    f1([计算分数]);
    c([Term2 <br>Chicken]);
    c1([计算分数]);
    n([Term3 <br>Nice]);
    n1([计算分数]);
    e([汇总得分并排序输出]);
    fcn --&gt; f &amp; c &amp; n
    f --&gt; f1
    c --&gt; c1
    n --&gt; n1
    f1 &amp; c1 &amp; n1 --&gt; e
</div>

<h3 id="bool-数字类型的查询">
<a class="anchor" href="#bool-%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%9F%A5%E8%AF%A2" aria-hidden="true"><span class="octicon octicon-link"></span></a>bool， 数字类型的查询</h3>
<ul>
  <li>对于这种不需要分词的类型，可以考虑直接使用 termQuery 查询， 如果不需要计算排序，则使用 constant score 方式，转化为 filter</li>
  <li>多值字段，如 labels: [label1， label2] 则为包含关系， 如果需要精确查询则需要增加 labels_count 的字段， 结合起来做精确匹配</li>
</ul>

<h3 id="相关度计算">
<a class="anchor" href="#%E7%9B%B8%E5%85%B3%E5%BA%A6%E8%AE%A1%E7%AE%97" aria-hidden="true"><span class="octicon octicon-link"></span></a>相关度计算</h3>
<p>TF-IDF 和 BM-25</p>

<ul>
  <li>TF term frequency，一个词在全文中所有词中出现的次数</li>
  <li>StopWord 类似于 ‘的， 我’ 这样的词，计算 TF 是没有意义的</li>
  <li>DF document frequency， 出现过该词的文档，在总文档中的次数， 也就是说该值越大，说明该词就越常见， 值越小，就越稀缺和重要。</li>
  <li>IDF inverse DF</li>
</ul>

<blockquote>
  <p>简单来说一个词的 TF 越高，DF 越低，文档越短，而认为相关度越高</p>
</blockquote>

<p>Boosting， boost 的意思是放大的意思，通过这个值可以控制算分结果</p>

<ul>
  <li>
<a href="https://www.elastic.co/guide/en/app-search/current/relevance-tuning-guide.html#relevance-tuning-guide" target="_blank" rel="noopener noreferrer">Boosting Query</a> 在查询的时候指定字段的 weight</li>
  <li>
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-field-value-factor" target="_blank" rel="noopener noreferrer">Function Score Query</a> 自定义字段/值的分数计算</li>
</ul>

<h3 id="query-和-filter">
<a class="anchor" href="#query-%E5%92%8C-filter" aria-hidden="true"><span class="octicon octicon-link"></span></a>Query 和 Filter</h3>
<p>Query 会进行相关性算分，Filter 只是过滤，不进行算分，性能相对更好</p>

<ul>
  <li>Bool Query
    <ul>
      <li>must QueryContext 会算分</li>
      <li>should QueryContext 会算分</li>
      <li>must_not FilterContext 不会算分</li>
      <li>filter FilterContext 必须匹配，不会算分</li>
    </ul>
  </li>
</ul>

<h3 id="function-score-query">
<a class="anchor" href="#function-score-query" aria-hidden="true"><span class="octicon octicon-link"></span></a>Function Score Query</h3>
<p>可以自定义算分结果</p>

<h3 id="serach-template">
<a class="anchor" href="#serach-template" aria-hidden="true"><span class="octicon octicon-link"></span></a>Serach Template</h3>
<p>搜索的定义 和 搜索的逻辑解耦</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST _scripts/media_serach_template
<span class="o">{</span>
  <span class="s2">"script"</span>: <span class="o">{</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="搜索推荐-search-as-you-type-autocomplete-contextcomplete">
<a class="anchor" href="#%E6%90%9C%E7%B4%A2%E6%8E%A8%E8%8D%90-search-as-you-type-autocomplete-contextcomplete" aria-hidden="true"><span class="octicon octicon-link"></span></a>搜索推荐 search as you type， AutoComplete， ContextComplete</h3>
<ul>
  <li>Term Suggestion，比如你搜索 go， 自动补全为 good god 等</li>
  <li>Phase Suggestion， 比如搜索 I love， 自动建议 I love you， I love dog， I love cat 等等</li>
  <li>AutoComplete， ES 在内存中建一个 <a href="https://en.wikipedia.org/wiki/Finite-state_transducer" target="_blank" rel="noopener noreferrer">fst(finate state transducer)</a> 进行检索，该结构类似于 tire， 对比可参考这篇<a href="https://blog.burntsushi.net/transducers/" target="_blank" rel="noopener noreferrer">文章</a> 该部分需要提前在索引中做定义</li>
  <li>ContextComplete，根据上下文进行推荐</li>
</ul>

<h3 id="es-分布式">
<a class="anchor" href="#es-%E5%88%86%E5%B8%83%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES 分布式</h3>
<ul>
  <li>故障转移
    <ul>
      <li>当前 shard 存放的副本，是其他的 shard 的副本</li>
      <li>当前 shard 挂掉之后，其他的 shard 会自动同步副本数据</li>
    </ul>

    <p><img src="assets/images/es_shard_example.png" alt="es_shard_example"></p>
  </li>
  <li>文档分布存储
    <ul>
      <li>路由算法 Hash(_routing) % primary_shards, 这里的 primary_shards 一旦更改，则需要重建索引</li>
    </ul>
  </li>
  <li>倒排索引是不可变的
    <ul>
      <li>好处: 不需要考虑并发，很好地利用文件系统的缓存，易于压缩</li>
      <li>坏处: 重建索引的成本比较高</li>
      <li>删除的索引单独存储，搜索的时候，先搜索全部，再过滤掉删除的文档</li>
    </ul>
  </li>
  <li>Refresh
    <ul>
      <li>单个倒排索引为多个 segment (不可变) 多个 segments + .del = 所有的数据集合</li>
      <li>index buffer 为 索引的内存空间, 索引的时候会先写入 index buffer</li>
      <li>index buffer 写入 segment 的过程为 refresh</li>
      <li>默认是 1s 进行一次 refresh，由于只有进入了 segment 才会被搜索，所以 es 是近实时的搜索引擎(延迟&lt;=1s)</li>
      <li>index buffer 占用内存过多(JVM的 10%) 也会触发 refresh</li>
    </ul>
  </li>
  <li>Transaction Log
    <ul>
      <li>在写入 index buffer 时候，同步地写入了 transaction log</li>
      <li>Transaction Log 在 ES 断电的时候，依然能够进行数据的恢复</li>
    </ul>
  </li>
  <li>Flush
    <ul>
      <li>refresh</li>
      <li>将缓存中的 segment 落到磁盘 (fsync)</li>
      <li>清空 transaction log</li>
      <li>默认 30分钟 调用一次 或者 transaction log 写满(512M)时 调用</li>
    </ul>
  </li>
  <li>Merge
    <ul>
      <li>merge 磁盘的 segment</li>
      <li>真正的删除</li>
    </ul>
  </li>
  <li>Search Type
    <ul>
      <li>DFS Query &amp;/then Fetch</li>
    </ul>
  </li>
</ul>

<h3 id="分片的生命周期">
<a class="anchor" href="#%E5%88%86%E7%89%87%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" aria-hidden="true"><span class="octicon octicon-link"></span></a>分片的生命周期</h3>
<p>TODO: 增删改查的步骤是什么样的，如何使用 内存，磁盘 等来做到 高性能 和 高可用的？</p>

<p>分片数目 和 相关性分数的关系</p>

<h3 id="深度分页-并发更新">
<a class="anchor" href="#%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5-%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>深度分页, 并发更新</h3>
<ul>
  <li>深度分页会导致非常大的性能问题，ES 默认的限制是 10000 条，可以考虑 <code class="language-plaintext highlighter-rouge">search after</code> 或者 <code class="language-plaintext highlighter-rouge">scroll</code> API 来解决深度分页问题</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>乐观锁, version = f(seq_no, primary_term)</td>
          <td> </td>
          <td>external_version</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="聚合查询">
<a class="anchor" href="#%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2" aria-hidden="true"><span class="octicon octicon-link"></span></a>聚合查询</h3>
<ul>
  <li>metric, 如 max, mix, avg, sum 等</li>
  <li>bucket, 类似于 groupBy</li>
</ul>

<h3 id="关联查询">
<a class="anchor" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2" aria-hidden="true"><span class="octicon octicon-link"></span></a>关联查询</h3>
<p>类似于 JOIN</p>

<ul>
  <li>object, user 对应的 name 字段，变为 user.name 字段, 会分别进行索引</li>
  <li>nested, 支持多个字段在一条记录中的查找</li>
  <li>children, 需要将父子文档存储在同一个分片上，此时子文档在创建索引的时候，需要加上父文档的 id</li>
</ul>

<h3 id="重建索引">
<a class="anchor" href="#%E9%87%8D%E5%BB%BA%E7%B4%A2%E5%BC%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>重建索引</h3>
<p>什么需要重建索引</p>

<ul>
  <li>索引相关的 Mapping 变更, 如 分析器，字段类型</li>
  <li>主分片数变更</li>
  <li>数据迁移等</li>
</ul>

<p>相关 API</p>

<ul>
  <li>update by query 在改变所以之前的字段, 也可以被索引到</li>
  <li>reindex</li>
</ul>

<h3 id="数据建模">
<a class="anchor" href="#%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1" aria-hidden="true"><span class="octicon octicon-link"></span></a>数据建模</h3>
<p>考虑以下的几个维度</p>

<ul>
  <li>使用的字段</li>
  <li>是否需要全文索引</li>
  <li>是否需要进行聚合和排序</li>
  <li>存储大小</li>
</ul>

<p>字段类型</p>

<ul>
  <li>Text(全文检索) 还是 Keyword(精确匹配, 排序, 聚合)，ES 默认会给 text 类型的字段 设置一个 keyword 字段, 平时考虑可以添加 英文/拼音 的字段，提高用户体验</li>
  <li>枚举类型尽量设置为 keyword</li>
  <li>不需要检索的字段设置 index 为 false</li>
</ul>

<p>其他</p>

<ul>
  <li>如果确认字段和字段类型，建议索引的 dynamic 设置为 strict</li>
  <li>避免正则匹配查询，而是通过字段冗余来解决(空间换时间)</li>
  <li>Mapping文件放入版本库中进行管理</li>
</ul>

<h2 id="reference">
<a class="anchor" href="#reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reference</h2>
<ul>
  <li><a href="https://time.geekbang.org/column/intro/298" target="_blank" rel="noopener noreferrer">检索技术核心20讲-极客时间</a></li>
  <li><a href="https://time.geekbang.org/course/detail/100030501-102662" target="_blank" rel="noopener noreferrer">Elasticsearch核心技术与实战-极客时间</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/142833556" target="_blank" rel="noopener noreferrer">H2 全文检索</a></li>
  <li><a href="https://dev.mysql.com/doc/refman/8.0/en/fulltext-search.html" target="_blank" rel="noopener noreferrer">MySQL Full-Text Search Functions</a></li>
  <li><a href="https://www.elastic.co/guide/en/app-search/current/relevance-tuning-guide.html#relevance-tuning-guide" target="_blank" rel="noopener noreferrer">Relevance Tuning Guide，Weights and Boosts</a></li>
  <li><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high-query-builders.html" target="_blank" rel="noopener noreferrer">QueryBuilders</a></li>
  <li><a href="https://www.infoq.com/articles/similarity-scoring-elasticsearch/" target="_blank" rel="noopener noreferrer">similarity-scoring-elasticsearch</a></li>
</ul>

</article>

<div id="comment"></div>
<script>
  gitalk.render('comment');
</script>



      </div>
    </main>

    
  </body>
</html>